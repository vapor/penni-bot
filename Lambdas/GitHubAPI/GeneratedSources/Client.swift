// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime

#if os(Linux)
@preconcurrency import Foundation
#else
import Foundation
#endif
/// GitHub's v3 REST API.
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter { client.converter }
    /// Create an installation access token for an app
    ///
    /// Creates an installation access token that enables a GitHub App to make authenticated API requests for the app's installation on an organization or individual account. Installation tokens expire one hour from the time you create them. Using an expired token produces a status code of `401 - Unauthorized`, and requires creating a new installation token. By default the installation token has access to all repositories that the installation can access. To restrict the access to specific repositories, you can provide the `repository_ids` when creating the token. When you omit `repository_ids`, the response does not contain the `repositories` key.
    ///
    /// You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
    ///
    /// - Remark: HTTP `POST /app/installations/{installation_id}/access_tokens`.
    /// - Remark: Generated from `#/paths//app/installations/{installation_id}/access_tokens/post(apps/create-installation-access-token)`.
    public func apps_create_installation_access_token(
        _ input: Operations.apps_create_installation_access_token.Input
    ) async throws -> Operations.apps_create_installation_access_token.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apps_create_installation_access_token.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/app/installations/{}/access_tokens",
                    parameters: [input.path.installation_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                switch input.body {
                case .none: request.body = nil
                case let .json(value):
                    request.body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers:
                        Operations.apps_create_installation_access_token.Output.Created.Headers =
                            .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.apps_create_installation_access_token.Output.Created.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.installation_token.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .created(.init(headers: headers, body: body))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.forbidden.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.requires_authentication.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .unauthorized(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.not_found.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .notFound(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.validation_failed.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.validation_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get an organization
    ///
    /// To see many of the organization response values, you need to be an authenticated organization owner with the `admin:org` scope. When the value of `two_factor_requirement_enabled` is `true`, the organization requires all members, billing managers, and outside collaborators to enable [two-factor authentication](https://docs.github.com/articles/securing-your-account-with-two-factor-authentication-2fa/).
    ///
    /// GitHub Apps with the `Organization plan` permission can use this endpoint to retrieve information about an organization's GitHub plan. See "[Authenticating with GitHub Apps](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/)" for details. For an example response, see 'Response with GitHub plan information' below."
    ///
    /// - Remark: HTTP `GET /orgs/{org}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/get(orgs/get)`.
    public func orgs_get(_ input: Operations.orgs_get.Input) async throws
        -> Operations.orgs_get.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.orgs_get.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/orgs/{}",
                    parameters: [input.path.org]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.orgs_get.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.orgs_get.Output.Ok.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.organization_full.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .ok(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.not_found.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get a repository
    ///
    /// The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
    ///
    /// **Note:** In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/get(repos/get)`.
    public func repos_get(_ input: Operations.repos_get.Input) async throws
        -> Operations.repos_get.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_get.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_get.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.repos_get.Output.Ok.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.full_repository.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .ok(.init(headers: headers, body: body))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.forbidden.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.not_found.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .notFound(.init(headers: headers, body: body))
                case 301:
                    let headers: Components.Responses.moved_permanently.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.moved_permanently.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .movedPermanently(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List pull requests associated with a commit
    ///
    /// Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, will only return open pull requests associated with the commit.
    ///
    /// To list the open or merged pull requests associated with a branch, you can set the `commit_sha` parameter to the branch name.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/pulls/get(repos/list-pull-requests-associated-with-commit)`.
    public func repos_list_pull_requests_associated_with_commit(
        _ input: Operations.repos_list_pull_requests_associated_with_commit.Input
    ) async throws -> Operations.repos_list_pull_requests_associated_with_commit.Output {
        try await client.send(
            input: input,
            forOperation: Operations.repos_list_pull_requests_associated_with_commit.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/commits/{}/pulls",
                    parameters: [input.path.owner, input.path.repo, input.path.commit_sha]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers:
                        Operations.repos_list_pull_requests_associated_with_commit.Output.Ok.Headers =
                            .init(
                                Link: try converter.getOptionalHeaderFieldAsText(
                                    in: response.headerFields,
                                    name: "Link",
                                    as: Components.Headers.link.self
                                )
                            )
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body:
                        Operations.repos_list_pull_requests_associated_with_commit.Output.Ok.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        [Components.Schemas.pull_request_simple].self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .ok(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Compare two commits
    ///
    /// Compares two commits against one another. You can compare branches in the same repository, or you can compare branches that exist in different repositories within the same repository network, including fork branches. For more information about how to view a repository's network, see "[Understanding connections between repositories](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository/understanding-connections-between-repositories)."
    ///
    /// This endpoint is equivalent to running the `git log BASE..HEAD` command, but it returns commits in a different order. The `git log BASE..HEAD` command returns commits in reverse chronological order, whereas the API returns commits in chronological order. You can pass the appropriate [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.
    ///
    /// The API response includes details about the files that were changed between the two commits. This includes the status of the change (if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.
    ///
    /// When calling this endpoint without any paging parameter (`per_page` or `page`), the returned list is limited to 250 commits, and the last commit in the list is the most recent of the entire comparison.
    ///
    /// **Working with large comparisons**
    ///
    /// To process a response with a large number of commits, use a query parameter (`per_page` or `page`) to paginate the results. When using pagination:
    ///
    /// - The list of changed files is only shown on the first page of results, but it includes all changed files for the entire comparison.
    /// - The results are returned in chronological order, but the last commit in the returned list may not be the most recent one in the entire set if there are more pages of results.
    ///
    /// For more information on working with pagination, see "[Using pagination in the REST API](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api)."
    ///
    /// **Signature verification object**
    ///
    /// The response will include a `verification` object that describes the result of verifying the commit's signature. The `verification` object includes the following fields:
    ///
    /// | Name | Type | Description |
    /// | ---- | ---- | ----------- |
    /// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    /// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    /// | `signature` | `string` | The signature that was extracted from the commit. |
    /// | `payload` | `string` | The value that was signed. |
    ///
    /// These are the possible values for `reason` in the `verification` object:
    ///
    /// | Value | Description |
    /// | ----- | ----------- |
    /// | `expired_key` | The key that made the signature is expired. |
    /// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    /// | `gpgverify_error` | There was an error communicating with the signature verification service. |
    /// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    /// | `unsigned` | The object does not include a signature. |
    /// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    /// | `no_user` | No user was associated with the `committer` email address in the commit. |
    /// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
    /// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    /// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    /// | `malformed_signature` | There was an error parsing the signature. |
    /// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    /// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/compare/{basehead}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/compare/{basehead}/get(repos/compare-commits)`.
    public func repos_compare_commits(_ input: Operations.repos_compare_commits.Input) async throws
        -> Operations.repos_compare_commits.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_compare_commits.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/compare/{}",
                    parameters: [input.path.owner, input.path.repo, input.path.basehead]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_compare_commits.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.repos_compare_commits.Output.Ok.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.commit_comparison.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .ok(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.not_found.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .notFound(.init(headers: headers, body: body))
                case 500:
                    let headers: Components.Responses.internal_error.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.internal_error.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .internalServerError(.init(headers: headers, body: body))
                case 503:
                    let headers: Components.Responses.service_unavailable.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.service_unavailable.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Responses.service_unavailable.Body.jsonPayload.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .serviceUnavailable(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List repository contributors
    ///
    /// Lists contributors to the specified repository and sorts them by the number of commits per contributor in descending order. This endpoint may return information that is a few hours old because the GitHub REST API caches contributor data to improve performance.
    ///
    /// GitHub identifies contributors by author email address. This endpoint groups contribution counts by GitHub user, which includes all associated email addresses. To improve performance, only the first 500 author email addresses in the repository link to GitHub users. The rest will appear as anonymous contributors without associated GitHub user information.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/contributors`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contributors/get(repos/list-contributors)`.
    public func repos_list_contributors(_ input: Operations.repos_list_contributors.Input)
        async throws -> Operations.repos_list_contributors.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_list_contributors.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/contributors",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "anon",
                    value: input.query.anon
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_list_contributors.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.repos_list_contributors.Output.Ok.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        [Components.Schemas.contributor].self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .ok(.init(headers: headers, body: body))
                case 204:
                    let headers: Operations.repos_list_contributors.Output.NoContent.Headers =
                        .init()
                    return .noContent(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.forbidden.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.not_found.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List repository issues
    ///
    /// List issues in a repository. Only open issues will be listed.
    ///
    /// **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
    /// reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
    /// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
    /// request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/issues`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/issues/get(issues/list-for-repo)`.
    public func issues_list_for_repo(_ input: Operations.issues_list_for_repo.Input) async throws
        -> Operations.issues_list_for_repo.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.issues_list_for_repo.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/issues",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "milestone",
                    value: input.query.milestone
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "state",
                    value: input.query.state
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "assignee",
                    value: input.query.assignee
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "creator",
                    value: input.query.creator
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "mentioned",
                    value: input.query.mentioned
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "labels",
                    value: input.query.labels
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.issues_list_for_repo.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.issues_list_for_repo.Output.Ok.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        [Components.Schemas.issue].self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .ok(.init(headers: headers, body: body))
                case 301:
                    let headers: Components.Responses.moved_permanently.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.moved_permanently.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .movedPermanently(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.validation_failed.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.validation_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.not_found.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create an issue
    ///
    /// Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://docs.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/issues`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/issues/post(issues/create)`.
    public func issues_create(_ input: Operations.issues_create.Input) async throws
        -> Operations.issues_create.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.issues_create.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/issues",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers: Operations.issues_create.Output.Created.Headers = .init(
                        Location: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Location",
                            as: Swift.String.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.issues_create.Output.Created.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.issue.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .created(.init(headers: headers, body: body))
                case 400:
                    let headers: Components.Responses.bad_request.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.bad_request.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .badRequest(.init(headers: headers, body: body))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.forbidden.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .forbidden(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.validation_failed.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.validation_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 503:
                    let headers: Components.Responses.service_unavailable.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.service_unavailable.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Responses.service_unavailable.Body.jsonPayload.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .serviceUnavailable(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.not_found.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .notFound(.init(headers: headers, body: body))
                case 410:
                    let headers: Components.Responses.gone.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.gone.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .gone(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create an issue comment
    ///
    ///
    /// You can use the REST API to create comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
    /// Creating content too quickly using this endpoint may result in secondary rate limiting.
    /// See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)"
    /// and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)"
    /// for details.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/issues/{issue_number}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/issues/{issue_number}/comments/post(issues/create-comment)`.
    public func issues_create_comment(_ input: Operations.issues_create_comment.Input) async throws
        -> Operations.issues_create_comment.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.issues_create_comment.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/issues/{}/comments",
                    parameters: [input.path.owner, input.path.repo, input.path.issue_number]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers: Operations.issues_create_comment.Output.Created.Headers = .init(
                        Location: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Location",
                            as: Swift.String.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.issues_create_comment.Output.Created.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.issue_comment.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .created(.init(headers: headers, body: body))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.forbidden.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .forbidden(.init(headers: headers, body: body))
                case 410:
                    let headers: Components.Responses.gone.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.gone.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .gone(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.validation_failed.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.validation_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.not_found.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List pull requests
    ///
    /// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pulls`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pulls/get(pulls/list)`.
    public func pulls_list(_ input: Operations.pulls_list.Input) async throws
        -> Operations.pulls_list.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.pulls_list.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/pulls",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "state",
                    value: input.query.state
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "head",
                    value: input.query.head
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "base",
                    value: input.query.base
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.pulls_list.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.pulls_list.Output.Ok.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        [Components.Schemas.pull_request_simple].self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .ok(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.validation_failed.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.validation_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List review comments on a pull request
    ///
    /// Lists all review comments for a pull request. By default, review comments are in ascending order by ID.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pulls/{pull_number}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pulls/{pull_number}/comments/get(pulls/list-review-comments)`.
    public func pulls_list_review_comments(_ input: Operations.pulls_list_review_comments.Input)
        async throws -> Operations.pulls_list_review_comments.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.pulls_list_review_comments.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/pulls/{}/comments",
                    parameters: [input.path.owner, input.path.repo, input.path.pull_number]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.pulls_list_review_comments.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.pulls_list_review_comments.Output.Ok.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        [Components.Schemas.pull_request_review_comment].self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .ok(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List pull requests files
    ///
    /// **Note:** Responses include a maximum of 3000 files. The paginated response returns 30 files per page by default.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pulls/{pull_number}/files`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pulls/{pull_number}/files/get(pulls/list-files)`.
    public func pulls_list_files(_ input: Operations.pulls_list_files.Input) async throws
        -> Operations.pulls_list_files.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.pulls_list_files.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/pulls/{}/files",
                    parameters: [input.path.owner, input.path.repo, input.path.pull_number]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.pulls_list_files.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.pulls_list_files.Output.Ok.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        [Components.Schemas.diff_entry].self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .ok(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.validation_failed.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.validation_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 500:
                    let headers: Components.Responses.internal_error.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.internal_error.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .internalServerError(.init(headers: headers, body: body))
                case 503:
                    let headers: Components.Responses.service_unavailable.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.service_unavailable.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Responses.service_unavailable.Body.jsonPayload.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .serviceUnavailable(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List releases
    ///
    /// This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/rest/reference/repos#list-repository-tags).
    ///
    /// Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/get(repos/list-releases)`.
    public func repos_list_releases(_ input: Operations.repos_list_releases.Input) async throws
        -> Operations.repos_list_releases.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_list_releases.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/releases",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_list_releases.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.repos_list_releases.Output.Ok.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        [Components.Schemas.release].self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .ok(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.not_found.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create a release
    ///
    /// Users with push access to the repository can create a release.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/releases`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/post(repos/create-release)`.
    public func repos_create_release(_ input: Operations.repos_create_release.Input) async throws
        -> Operations.repos_create_release.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_create_release.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/releases",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers: Operations.repos_create_release.Output.Created.Headers = .init(
                        Location: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Location",
                            as: Swift.String.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.repos_create_release.Output.Created.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.release.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .created(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.repos_create_release.Output.NotFound.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.repos_create_release.Output.NotFound.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .notFound(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Components.Responses.validation_failed.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.validation_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get the latest release
    ///
    /// View the latest published full release for the repository.
    ///
    /// The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/latest`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/latest/get(repos/get-latest-release)`.
    public func repos_get_latest_release(_ input: Operations.repos_get_latest_release.Input)
        async throws -> Operations.repos_get_latest_release.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_get_latest_release.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/releases/latest",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_get_latest_release.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.repos_get_latest_release.Output.Ok.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.release.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .ok(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List repository tags
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/tags`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/get(repos/list-tags)`.
    public func repos_list_tags(_ input: Operations.repos_list_tags.Input) async throws
        -> Operations.repos_list_tags.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_list_tags.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/tags",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_list_tags.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(
                        in: response.headerFields
                    )
                    let body: Operations.repos_list_tags.Output.Ok.Body
                    guard
                        try contentType == nil
                            || converter.isMatchingContentType(
                                received: contentType,
                                expectedRaw: "application/json"
                            )
                    else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    body = try converter.getResponseBodyAsJSON(
                        [Components.Schemas.tag].self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .ok(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
}
