// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import Foundation
#else
import Foundation
#endif
/// GitHub's v3 REST API.
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter { client.converter }
    /// Create an installation access token for an app
    ///
    /// Creates an installation access token that enables a GitHub App to make authenticated API requests for the app's installation on an organization or individual account. Installation tokens expire one hour from the time you create them. Using an expired token produces a status code of `401 - Unauthorized`, and requires creating a new installation token. By default the installation token has access to all repositories that the installation can access. To restrict the access to specific repositories, you can provide the `repository_ids` when creating the token. When you omit `repository_ids`, the response does not contain the `repositories` key.
    ///
    /// You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
    ///
    /// - Remark: HTTP `POST /app/installations/{installation_id}/access_tokens`.
    /// - Remark: Generated from `#/paths//app/installations/{installation_id}/access_tokens/post(apps/create-installation-access-token)`.
    public func apps_create_installation_access_token(_ input: Operations.apps_create_installation_access_token.Input)
        async throws -> Operations.apps_create_installation_access_token.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.apps_create_installation_access_token.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/app/installations/{}/access_tokens",
                    parameters: [input.path.installation_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case .none: request.body = nil
                case let .json(value):
                    request.body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers: Operations.apps_create_installation_access_token.Output.Created.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.apps_create_installation_access_token.Output.Created.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.installation_token.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .created(.init(headers: headers, body: body))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get an organization
    ///
    /// To see many of the organization response values, you need to be an authenticated organization owner with the `admin:org` scope. When the value of `two_factor_requirement_enabled` is `true`, the organization requires all members, billing managers, and outside collaborators to enable [two-factor authentication](https://docs.github.com/articles/securing-your-account-with-two-factor-authentication-2fa/).
    ///
    /// GitHub Apps with the `Organization plan` permission can use this endpoint to retrieve information about an organization's GitHub plan. See "[Authenticating with GitHub Apps](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/)" for details. For an example response, see 'Response with GitHub plan information' below."
    ///
    /// - Remark: HTTP `GET /orgs/{org}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/get(orgs/get)`.
    public func orgs_get(_ input: Operations.orgs_get.Input) async throws -> Operations.orgs_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.orgs_get.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/orgs/{}", parameters: [input.path.org])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.orgs_get.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.orgs_get.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.organization_full.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get a project card
    ///
    /// Gets information about a project card.
    ///
    /// - Remark: HTTP `GET /projects/columns/cards/{card_id}`.
    /// - Remark: Generated from `#/paths//projects/columns/cards/{card_id}/get(projects/get-card)`.
    public func projects_get_card(_ input: Operations.projects_get_card.Input) async throws
        -> Operations.projects_get_card.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_get_card.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/columns/cards/{}",
                    parameters: [input.path.card_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.projects_get_card.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_get_card.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.project_card.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Update an existing project card
    ///
    /// - Remark: HTTP `PATCH /projects/columns/cards/{card_id}`.
    /// - Remark: Generated from `#/paths//projects/columns/cards/{card_id}/patch(projects/update-card)`.
    public func projects_update_card(_ input: Operations.projects_update_card.Input) async throws
        -> Operations.projects_update_card.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_update_card.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/columns/cards/{}",
                    parameters: [input.path.card_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .patch)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case .none: request.body = nil
                case let .json(value):
                    request.body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.projects_update_card.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_update_card.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.project_card.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed_simple.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed_simple.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error_simple.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Delete a project card
    ///
    /// Deletes a project card
    ///
    /// - Remark: HTTP `DELETE /projects/columns/cards/{card_id}`.
    /// - Remark: Generated from `#/paths//projects/columns/cards/{card_id}/delete(projects/delete-card)`.
    public func projects_delete_card(_ input: Operations.projects_delete_card.Input) async throws
        -> Operations.projects_delete_card.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_delete_card.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/columns/cards/{}",
                    parameters: [input.path.card_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204:
                    let headers: Operations.projects_delete_card.Output.NoContent.Headers = .init()
                    return .noContent(.init(headers: headers, body: nil))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Operations.projects_delete_card.Output.Forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_delete_card.Output.Forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Operations.projects_delete_card.Output.Forbidden.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Move a project card
    ///
    /// - Remark: HTTP `POST /projects/columns/cards/{card_id}/moves`.
    /// - Remark: Generated from `#/paths//projects/columns/cards/{card_id}/moves/post(projects/move-card)`.
    public func projects_move_card(_ input: Operations.projects_move_card.Input) async throws
        -> Operations.projects_move_card.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_move_card.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/columns/cards/{}/moves",
                    parameters: [input.path.card_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers: Operations.projects_move_card.Output.Created.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_move_card.Output.Created.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Operations.projects_move_card.Output.Created.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .created(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Operations.projects_move_card.Output.Forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_move_card.Output.Forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Operations.projects_move_card.Output.Forbidden.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                case 503:
                    let headers: Operations.projects_move_card.Output.ServiceUnavailable.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_move_card.Output.ServiceUnavailable.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Operations.projects_move_card.Output.ServiceUnavailable.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .serviceUnavailable(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get a project column
    ///
    /// Gets information about a project column.
    ///
    /// - Remark: HTTP `GET /projects/columns/{column_id}`.
    /// - Remark: Generated from `#/paths//projects/columns/{column_id}/get(projects/get-column)`.
    public func projects_get_column(_ input: Operations.projects_get_column.Input) async throws
        -> Operations.projects_get_column.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_get_column.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/columns/{}",
                    parameters: [input.path.column_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.projects_get_column.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_get_column.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.project_column.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Update an existing project column
    ///
    /// - Remark: HTTP `PATCH /projects/columns/{column_id}`.
    /// - Remark: Generated from `#/paths//projects/columns/{column_id}/patch(projects/update-column)`.
    public func projects_update_column(_ input: Operations.projects_update_column.Input) async throws
        -> Operations.projects_update_column.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_update_column.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/columns/{}",
                    parameters: [input.path.column_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .patch)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.projects_update_column.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_update_column.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.project_column.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Delete a project column
    ///
    /// Deletes a project column.
    ///
    /// - Remark: HTTP `DELETE /projects/columns/{column_id}`.
    /// - Remark: Generated from `#/paths//projects/columns/{column_id}/delete(projects/delete-column)`.
    public func projects_delete_column(_ input: Operations.projects_delete_column.Input) async throws
        -> Operations.projects_delete_column.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_delete_column.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/columns/{}",
                    parameters: [input.path.column_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204:
                    let headers: Operations.projects_delete_column.Output.NoContent.Headers = .init()
                    return .noContent(.init(headers: headers, body: nil))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List project cards
    ///
    /// Lists the project cards in a project.
    ///
    /// - Remark: HTTP `GET /projects/columns/{column_id}/cards`.
    /// - Remark: Generated from `#/paths//projects/columns/{column_id}/cards/get(projects/list-cards)`.
    public func projects_list_cards(_ input: Operations.projects_list_cards.Input) async throws
        -> Operations.projects_list_cards.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_list_cards.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/columns/{}/cards",
                    parameters: [input.path.column_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "archived_state",
                    value: input.query.archived_state
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.projects_list_cards.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_list_cards.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            [Components.Schemas.project_card].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create a project card
    ///
    /// - Remark: HTTP `POST /projects/columns/{column_id}/cards`.
    /// - Remark: Generated from `#/paths//projects/columns/{column_id}/cards/post(projects/create-card)`.
    public func projects_create_card(_ input: Operations.projects_create_card.Input) async throws
        -> Operations.projects_create_card.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_create_card.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/columns/{}/cards",
                    parameters: [input.path.column_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers: Operations.projects_create_card.Output.Created.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_create_card.Output.Created.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.project_card.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .created(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                case 422:
                    let headers: Operations.projects_create_card.Output.UnprocessableEntity.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_create_card.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Operations.projects_create_card.Output.UnprocessableEntity.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 503:
                    let headers: Operations.projects_create_card.Output.ServiceUnavailable.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_create_card.Output.ServiceUnavailable.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Operations.projects_create_card.Output.ServiceUnavailable.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .serviceUnavailable(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Move a project column
    ///
    /// - Remark: HTTP `POST /projects/columns/{column_id}/moves`.
    /// - Remark: Generated from `#/paths//projects/columns/{column_id}/moves/post(projects/move-column)`.
    public func projects_move_column(_ input: Operations.projects_move_column.Input) async throws
        -> Operations.projects_move_column.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_move_column.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/columns/{}/moves",
                    parameters: [input.path.column_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers: Operations.projects_move_column.Output.Created.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_move_column.Output.Created.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Operations.projects_move_column.Output.Created.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .created(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed_simple.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed_simple.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error_simple.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get a project
    ///
    /// Gets a project by its `id`. Returns a `404 Not Found` status if projects are disabled. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// - Remark: HTTP `GET /projects/{project_id}`.
    /// - Remark: Generated from `#/paths//projects/{project_id}/get(projects/get)`.
    public func projects_get(_ input: Operations.projects_get.Input) async throws -> Operations.projects_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.projects_get.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/projects/{}", parameters: [input.path.project_id])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.projects_get.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_get.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.project.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Update a project
    ///
    /// Updates a project board's information. Returns a `404 Not Found` status if projects are disabled. If you do not have sufficient privileges to perform this action, a `401 Unauthorized` or `410 Gone` status is returned.
    ///
    /// - Remark: HTTP `PATCH /projects/{project_id}`.
    /// - Remark: Generated from `#/paths//projects/{project_id}/patch(projects/update)`.
    public func projects_update(_ input: Operations.projects_update.Input) async throws
        -> Operations.projects_update.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_update.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/projects/{}", parameters: [input.path.project_id])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .patch)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case .none: request.body = nil
                case let .json(value):
                    request.body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.projects_update.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_update.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.project.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.projects_update.Output.NotFound.Headers = .init()
                    return .notFound(.init(headers: headers, body: nil))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Operations.projects_update.Output.Forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_update.Output.Forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Operations.projects_update.Output.Forbidden.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                case 410:
                    let headers: Components.Responses.gone.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.gone.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .gone(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed_simple.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed_simple.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error_simple.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Delete a project
    ///
    /// Deletes a project board. Returns a `404 Not Found` status if projects are disabled.
    ///
    /// - Remark: HTTP `DELETE /projects/{project_id}`.
    /// - Remark: Generated from `#/paths//projects/{project_id}/delete(projects/delete)`.
    public func projects_delete(_ input: Operations.projects_delete.Input) async throws
        -> Operations.projects_delete.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_delete.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/projects/{}", parameters: [input.path.project_id])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204:
                    let headers: Operations.projects_delete.Output.NoContent.Headers = .init()
                    return .noContent(.init(headers: headers, body: nil))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Operations.projects_delete.Output.Forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_delete.Output.Forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Operations.projects_delete.Output.Forbidden.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                case 410:
                    let headers: Components.Responses.gone.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.gone.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .gone(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List project collaborators
    ///
    /// Lists the collaborators for an organization project. For a project, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners. You must be an organization owner or a project `admin` to list collaborators.
    ///
    /// - Remark: HTTP `GET /projects/{project_id}/collaborators`.
    /// - Remark: Generated from `#/paths//projects/{project_id}/collaborators/get(projects/list-collaborators)`.
    public func projects_list_collaborators(_ input: Operations.projects_list_collaborators.Input) async throws
        -> Operations.projects_list_collaborators.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_list_collaborators.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/{}/collaborators",
                    parameters: [input.path.project_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "affiliation",
                    value: input.query.affiliation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.projects_list_collaborators.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_list_collaborators.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            [Components.Schemas.simple_user].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Add project collaborator
    ///
    /// Adds a collaborator to an organization project and sets their permission level. You must be an organization owner or a project `admin` to add a collaborator.
    ///
    /// - Remark: HTTP `PUT /projects/{project_id}/collaborators/{username}`.
    /// - Remark: Generated from `#/paths//projects/{project_id}/collaborators/{username}/put(projects/add-collaborator)`.
    public func projects_add_collaborator(_ input: Operations.projects_add_collaborator.Input) async throws
        -> Operations.projects_add_collaborator.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_add_collaborator.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/{}/collaborators/{}",
                    parameters: [input.path.project_id, input.path.username]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .put)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case .none: request.body = nil
                case let .json(value):
                    request.body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204:
                    let headers: Operations.projects_add_collaborator.Output.NoContent.Headers = .init()
                    return .noContent(.init(headers: headers, body: nil))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Remove user as a collaborator
    ///
    /// Removes a collaborator from an organization project. You must be an organization owner or a project `admin` to remove a collaborator.
    ///
    /// - Remark: HTTP `DELETE /projects/{project_id}/collaborators/{username}`.
    /// - Remark: Generated from `#/paths//projects/{project_id}/collaborators/{username}/delete(projects/remove-collaborator)`.
    public func projects_remove_collaborator(_ input: Operations.projects_remove_collaborator.Input) async throws
        -> Operations.projects_remove_collaborator.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_remove_collaborator.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/{}/collaborators/{}",
                    parameters: [input.path.project_id, input.path.username]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204:
                    let headers: Operations.projects_remove_collaborator.Output.NoContent.Headers = .init()
                    return .noContent(.init(headers: headers, body: nil))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get project permission for a user
    ///
    /// Returns the collaborator's permission level for an organization project. Possible values for the `permission` key: `admin`, `write`, `read`, `none`. You must be an organization owner or a project `admin` to review a user's permission level.
    ///
    /// - Remark: HTTP `GET /projects/{project_id}/collaborators/{username}/permission`.
    /// - Remark: Generated from `#/paths//projects/{project_id}/collaborators/{username}/permission/get(projects/get-permission-for-user)`.
    public func projects_get_permission_for_user(_ input: Operations.projects_get_permission_for_user.Input)
        async throws -> Operations.projects_get_permission_for_user.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_get_permission_for_user.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/{}/collaborators/{}/permission",
                    parameters: [input.path.project_id, input.path.username]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.projects_get_permission_for_user.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_get_permission_for_user.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.project_collaborator_permission.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List project columns
    ///
    /// Lists the project columns in a project.
    ///
    /// - Remark: HTTP `GET /projects/{project_id}/columns`.
    /// - Remark: Generated from `#/paths//projects/{project_id}/columns/get(projects/list-columns)`.
    public func projects_list_columns(_ input: Operations.projects_list_columns.Input) async throws
        -> Operations.projects_list_columns.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_list_columns.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/{}/columns",
                    parameters: [input.path.project_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.projects_list_columns.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_list_columns.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            [Components.Schemas.project_column].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create a project column
    ///
    /// Creates a new project column.
    ///
    /// - Remark: HTTP `POST /projects/{project_id}/columns`.
    /// - Remark: Generated from `#/paths//projects/{project_id}/columns/post(projects/create-column)`.
    public func projects_create_column(_ input: Operations.projects_create_column.Input) async throws
        -> Operations.projects_create_column.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.projects_create_column.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/projects/{}/columns",
                    parameters: [input.path.project_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers: Operations.projects_create_column.Output.Created.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.projects_create_column.Output.Created.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.project_column.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .created(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed_simple.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed_simple.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error_simple.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.requires_authentication.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get rate limit status for the authenticated user
    ///
    /// **Note:** Accessing this endpoint does not count against your REST API rate limit.
    ///
    /// **Note:** The `rate` object is deprecated. If you're writing new API client code or updating existing code, you should use the `core` object instead of the `rate` object. The `core` object contains the same information that is present in the `rate` object.
    ///
    /// - Remark: HTTP `GET /rate_limit`.
    /// - Remark: Generated from `#/paths//rate_limit/get(rate-limit/get)`.
    public func rate_limit_get(_ input: Operations.rate_limit_get.Input) async throws
        -> Operations.rate_limit_get.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.rate_limit_get.id,
            serializer: { input in let path = try converter.renderedPath(template: "/rate_limit", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.rate_limit_get.Output.Ok.Headers = .init(
                        X_RateLimit_Limit: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "X-RateLimit-Limit",
                            as: Components.Headers.x_rate_limit_limit.self
                        ),
                        X_RateLimit_Remaining: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "X-RateLimit-Remaining",
                            as: Components.Headers.x_rate_limit_remaining.self
                        ),
                        X_RateLimit_Reset: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "X-RateLimit-Reset",
                            as: Components.Headers.x_rate_limit_reset.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.rate_limit_get.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.rate_limit_overview.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get a repository
    ///
    /// The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
    ///
    /// **Note:** In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/get(repos/get)`.
    public func repos_get(_ input: Operations.repos_get.Input) async throws -> Operations.repos_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.repos_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_get.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.repos_get.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.full_repository.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                case 301:
                    let headers: Components.Responses.moved_permanently.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.moved_permanently.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .movedPermanently(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List commits
    ///
    /// **Signature verification object**
    ///
    /// The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
    ///
    /// | Name | Type | Description |
    /// | ---- | ---- | ----------- |
    /// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    /// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    /// | `signature` | `string` | The signature that was extracted from the commit. |
    /// | `payload` | `string` | The value that was signed. |
    ///
    /// These are the possible values for `reason` in the `verification` object:
    ///
    /// | Value | Description |
    /// | ----- | ----------- |
    /// | `expired_key` | The key that made the signature is expired. |
    /// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    /// | `gpgverify_error` | There was an error communicating with the signature verification service. |
    /// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    /// | `unsigned` | The object does not include a signature. |
    /// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    /// | `no_user` | No user was associated with the `committer` email address in the commit. |
    /// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
    /// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    /// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    /// | `malformed_signature` | There was an error parsing the signature. |
    /// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    /// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/get(repos/list-commits)`.
    public func repos_list_commits(_ input: Operations.repos_list_commits.Input) async throws
        -> Operations.repos_list_commits.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_list_commits.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/commits",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sha",
                    value: input.query.sha
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "path",
                    value: input.query.path
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "author",
                    value: input.query.author
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "committer",
                    value: input.query.committer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "until",
                    value: input.query.until
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_list_commits.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.repos_list_commits.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            [Components.Schemas.commit].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 500:
                    let headers: Components.Responses.internal_error.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.internal_error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(headers: headers, body: body))
                case 400:
                    let headers: Components.Responses.bad_request.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.bad_request.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                case 409:
                    let headers: Components.Responses.conflict.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.conflict.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .conflict(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List pull requests associated with a commit
    ///
    /// Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, will only return open pull requests associated with the commit.
    ///
    /// To list the open or merged pull requests associated with a branch, you can set the `commit_sha` parameter to the branch name.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/pulls/get(repos/list-pull-requests-associated-with-commit)`.
    public func repos_list_pull_requests_associated_with_commit(
        _ input: Operations.repos_list_pull_requests_associated_with_commit.Input
    ) async throws -> Operations.repos_list_pull_requests_associated_with_commit.Output {
        try await client.send(
            input: input,
            forOperation: Operations.repos_list_pull_requests_associated_with_commit.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/commits/{}/pulls",
                    parameters: [input.path.owner, input.path.repo, input.path.commit_sha]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_list_pull_requests_associated_with_commit.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.repos_list_pull_requests_associated_with_commit.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            [Components.Schemas.pull_request_simple].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Compare two commits
    ///
    /// Compares two commits against one another. You can compare branches in the same repository, or you can compare branches that exist in different repositories within the same repository network, including fork branches. For more information about how to view a repository's network, see "[Understanding connections between repositories](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository/understanding-connections-between-repositories)."
    ///
    /// This endpoint is equivalent to running the `git log BASE..HEAD` command, but it returns commits in a different order. The `git log BASE..HEAD` command returns commits in reverse chronological order, whereas the API returns commits in chronological order. You can pass the appropriate [media type](https://docs.github.com/rest/overview/media-types/#commits-commit-comparison-and-pull-requests) to fetch diff and patch formats.
    ///
    /// The API response includes details about the files that were changed between the two commits. This includes the status of the change (if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.
    ///
    /// When calling this endpoint without any paging parameter (`per_page` or `page`), the returned list is limited to 250 commits, and the last commit in the list is the most recent of the entire comparison.
    ///
    /// **Working with large comparisons**
    ///
    /// To process a response with a large number of commits, use a query parameter (`per_page` or `page`) to paginate the results. When using pagination:
    ///
    /// - The list of changed files is only shown on the first page of results, but it includes all changed files for the entire comparison.
    /// - The results are returned in chronological order, but the last commit in the returned list may not be the most recent one in the entire set if there are more pages of results.
    ///
    /// For more information on working with pagination, see "[Using pagination in the REST API](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api)."
    ///
    /// **Signature verification object**
    ///
    /// The response will include a `verification` object that describes the result of verifying the commit's signature. The `verification` object includes the following fields:
    ///
    /// | Name | Type | Description |
    /// | ---- | ---- | ----------- |
    /// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    /// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    /// | `signature` | `string` | The signature that was extracted from the commit. |
    /// | `payload` | `string` | The value that was signed. |
    ///
    /// These are the possible values for `reason` in the `verification` object:
    ///
    /// | Value | Description |
    /// | ----- | ----------- |
    /// | `expired_key` | The key that made the signature is expired. |
    /// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    /// | `gpgverify_error` | There was an error communicating with the signature verification service. |
    /// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    /// | `unsigned` | The object does not include a signature. |
    /// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    /// | `no_user` | No user was associated with the `committer` email address in the commit. |
    /// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
    /// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    /// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    /// | `malformed_signature` | There was an error parsing the signature. |
    /// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    /// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/compare/{basehead}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/compare/{basehead}/get(repos/compare-commits)`.
    public func repos_compare_commits(_ input: Operations.repos_compare_commits.Input) async throws
        -> Operations.repos_compare_commits.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_compare_commits.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/compare/{}",
                    parameters: [input.path.owner, input.path.repo, input.path.basehead]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_compare_commits.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.repos_compare_commits.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.commit_comparison.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                case 500:
                    let headers: Components.Responses.internal_error.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.internal_error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(headers: headers, body: body))
                case 503:
                    let headers: Components.Responses.service_unavailable.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.service_unavailable.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Responses.service_unavailable.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .serviceUnavailable(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List repository contributors
    ///
    /// Lists contributors to the specified repository and sorts them by the number of commits per contributor in descending order. This endpoint may return information that is a few hours old because the GitHub REST API caches contributor data to improve performance.
    ///
    /// GitHub identifies contributors by author email address. This endpoint groups contribution counts by GitHub user, which includes all associated email addresses. To improve performance, only the first 500 author email addresses in the repository link to GitHub users. The rest will appear as anonymous contributors without associated GitHub user information.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/contributors`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contributors/get(repos/list-contributors)`.
    public func repos_list_contributors(_ input: Operations.repos_list_contributors.Input) async throws
        -> Operations.repos_list_contributors.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_list_contributors.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/contributors",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "anon",
                    value: input.query.anon
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_list_contributors.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.repos_list_contributors.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            [Components.Schemas.contributor].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 204:
                    let headers: Operations.repos_list_contributors.Output.NoContent.Headers = .init()
                    return .noContent(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List repository issues
    ///
    /// List issues in a repository. Only open issues will be listed.
    ///
    /// **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
    /// reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
    /// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
    /// request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/issues`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/issues/get(issues/list-for-repo)`.
    public func issues_list_for_repo(_ input: Operations.issues_list_for_repo.Input) async throws
        -> Operations.issues_list_for_repo.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.issues_list_for_repo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/issues",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "milestone",
                    value: input.query.milestone
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "state",
                    value: input.query.state
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "assignee",
                    value: input.query.assignee
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "creator",
                    value: input.query.creator
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "mentioned",
                    value: input.query.mentioned
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "labels",
                    value: input.query.labels
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.issues_list_for_repo.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.issues_list_for_repo.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            [Components.Schemas.issue].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 301:
                    let headers: Components.Responses.moved_permanently.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.moved_permanently.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .movedPermanently(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create an issue
    ///
    /// Any user with pull access to a repository can create an issue. If [issues are disabled in the repository](https://docs.github.com/articles/disabling-issues/), the API returns a `410 Gone` status.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/issues`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/issues/post(issues/create)`.
    public func issues_create(_ input: Operations.issues_create.Input) async throws -> Operations.issues_create.Output {
        try await client.send(
            input: input,
            forOperation: Operations.issues_create.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/issues",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers: Operations.issues_create.Output.Created.Headers = .init(
                        Location: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Location",
                            as: Swift.String.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.issues_create.Output.Created.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.issue.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .created(.init(headers: headers, body: body))
                case 400:
                    let headers: Components.Responses.bad_request.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.bad_request.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(headers: headers, body: body))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 503:
                    let headers: Components.Responses.service_unavailable.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.service_unavailable.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Responses.service_unavailable.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .serviceUnavailable(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                case 410:
                    let headers: Components.Responses.gone.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.gone.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .gone(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get an issue
    ///
    /// The API returns a [`301 Moved Permanently` status](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-redirects-redirects) if the issue was
    /// [transferred](https://docs.github.com/articles/transferring-an-issue-to-another-repository/) to another repository. If
    /// the issue was transferred to or deleted from a repository where the authenticated user lacks read access, the API
    /// returns a `404 Not Found` status. If the issue was deleted from a repository where the authenticated user has read
    /// access, the API returns a `410 Gone` status. To receive webhook events for transferred and deleted issues, subscribe
    /// to the [`issues`](https://docs.github.com/webhooks/event-payloads/#issues) webhook.
    ///
    /// **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
    /// reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
    /// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
    /// request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/issues/{issue_number}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/issues/{issue_number}/get(issues/get)`.
    public func issues_get(_ input: Operations.issues_get.Input) async throws -> Operations.issues_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.issues_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/issues/{}",
                    parameters: [input.path.owner, input.path.repo, input.path.issue_number]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.issues_get.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.issues_get.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.issue.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 301:
                    let headers: Components.Responses.moved_permanently.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.moved_permanently.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .movedPermanently(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                case 410:
                    let headers: Components.Responses.gone.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.gone.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .gone(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Update an issue
    ///
    /// Issue owners and users with push access can edit an issue.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/issues/{issue_number}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/issues/{issue_number}/patch(issues/update)`.
    public func issues_update(_ input: Operations.issues_update.Input) async throws -> Operations.issues_update.Output {
        try await client.send(
            input: input,
            forOperation: Operations.issues_update.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/issues/{}",
                    parameters: [input.path.owner, input.path.repo, input.path.issue_number]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .patch)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case .none: request.body = nil
                case let .json(value):
                    request.body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.issues_update.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.issues_update.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.issue.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 503:
                    let headers: Components.Responses.service_unavailable.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.service_unavailable.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Responses.service_unavailable.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .serviceUnavailable(.init(headers: headers, body: body))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 301:
                    let headers: Components.Responses.moved_permanently.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.moved_permanently.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .movedPermanently(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                case 410:
                    let headers: Components.Responses.gone.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.gone.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .gone(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create an issue comment
    ///
    ///
    /// You can use the REST API to create comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
    /// Creating content too quickly using this endpoint may result in secondary rate limiting.
    /// See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)"
    /// and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)"
    /// for details.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/issues/{issue_number}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/issues/{issue_number}/comments/post(issues/create-comment)`.
    public func issues_create_comment(_ input: Operations.issues_create_comment.Input) async throws
        -> Operations.issues_create_comment.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.issues_create_comment.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/issues/{}/comments",
                    parameters: [input.path.owner, input.path.repo, input.path.issue_number]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers: Operations.issues_create_comment.Output.Created.Headers = .init(
                        Location: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Location",
                            as: Swift.String.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.issues_create_comment.Output.Created.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.issue_comment.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .created(.init(headers: headers, body: body))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.forbidden.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .forbidden(.init(headers: headers, body: body))
                case 410:
                    let headers: Components.Responses.gone.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.gone.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .gone(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List pull requests
    ///
    /// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pulls`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pulls/get(pulls/list)`.
    public func pulls_list(_ input: Operations.pulls_list.Input) async throws -> Operations.pulls_list.Output {
        try await client.send(
            input: input,
            forOperation: Operations.pulls_list.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/pulls",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "state",
                    value: input.query.state
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "head",
                    value: input.query.head
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "base",
                    value: input.query.base
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.pulls_list.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.pulls_list.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            [Components.Schemas.pull_request_simple].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List review comments on a pull request
    ///
    /// Lists all review comments for a pull request. By default, review comments are in ascending order by ID.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pulls/{pull_number}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pulls/{pull_number}/comments/get(pulls/list-review-comments)`.
    public func pulls_list_review_comments(_ input: Operations.pulls_list_review_comments.Input) async throws
        -> Operations.pulls_list_review_comments.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.pulls_list_review_comments.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/pulls/{}/comments",
                    parameters: [input.path.owner, input.path.repo, input.path.pull_number]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.pulls_list_review_comments.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.pulls_list_review_comments.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            [Components.Schemas.pull_request_review_comment].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List pull requests files
    ///
    /// **Note:** Responses include a maximum of 3000 files. The paginated response returns 30 files per page by default.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pulls/{pull_number}/files`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pulls/{pull_number}/files/get(pulls/list-files)`.
    public func pulls_list_files(_ input: Operations.pulls_list_files.Input) async throws
        -> Operations.pulls_list_files.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.pulls_list_files.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/pulls/{}/files",
                    parameters: [input.path.owner, input.path.repo, input.path.pull_number]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.pulls_list_files.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.pulls_list_files.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            [Components.Schemas.diff_entry].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 500:
                    let headers: Components.Responses.internal_error.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.internal_error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(headers: headers, body: body))
                case 503:
                    let headers: Components.Responses.service_unavailable.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.service_unavailable.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Responses.service_unavailable.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .serviceUnavailable(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List releases
    ///
    /// This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/rest/reference/repos#list-repository-tags).
    ///
    /// Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/get(repos/list-releases)`.
    public func repos_list_releases(_ input: Operations.repos_list_releases.Input) async throws
        -> Operations.repos_list_releases.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_list_releases.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/releases",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_list_releases.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.repos_list_releases.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            [Components.Schemas.release].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.not_found.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create a release
    ///
    /// Users with push access to the repository can create a release.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/releases`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/post(repos/create-release)`.
    public func repos_create_release(_ input: Operations.repos_create_release.Input) async throws
        -> Operations.repos_create_release.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_create_release.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/releases",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers: Operations.repos_create_release.Output.Created.Headers = .init(
                        Location: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Location",
                            as: Swift.String.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.repos_create_release.Output.Created.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.release.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .created(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.repos_create_release.Output.NotFound.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.repos_create_release.Output.NotFound.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses.validation_failed.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get the latest release
    ///
    /// View the latest published full release for the repository.
    ///
    /// The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/latest`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/latest/get(repos/get-latest-release)`.
    public func repos_get_latest_release(_ input: Operations.repos_get_latest_release.Input) async throws
        -> Operations.repos_get_latest_release.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_get_latest_release.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/releases/latest",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_get_latest_release.Output.Ok.Headers = .init()
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.repos_get_latest_release.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.release.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List repository tags
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/tags`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/get(repos/list-tags)`.
    public func repos_list_tags(_ input: Operations.repos_list_tags.Input) async throws
        -> Operations.repos_list_tags.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_list_tags.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/repos/{}/{}/tags",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_list_tags.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsURI(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.repos_list_tags.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            [Components.Schemas.tag].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
}
