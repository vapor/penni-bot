// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import Foundation
#else
import Foundation
#endif
/// GitHub's v3 REST API.
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter { client.converter }
    /// Get an organization
    ///
    /// To see many of the organization response values, you need to be an authenticated organization owner with the `admin:org` scope. When the value of `two_factor_requirement_enabled` is `true`, the organization requires all members, billing managers, and outside collaborators to enable [two-factor authentication](https://docs.github.com/articles/securing-your-account-with-two-factor-authentication-2fa/).
    ///
    /// GitHub Apps with the `Organization plan` permission can use this endpoint to retrieve information about an organization's GitHub plan. See "[Authenticating with GitHub Apps](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/)" for details. For an example response, see 'Response with GitHub plan information' below."
    ///
    /// - Remark: HTTP `GET /orgs/{org}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/get(orgs/get)`.
    public func orgs_get(_ input: Operations.orgs_get.Input) async throws
        -> Operations.orgs_get.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.orgs_get.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/orgs/{}",
                    parameters: [input.path.org]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.orgs_get.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.orgs_get.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.organization_full.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.not_found.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get a repository
    ///
    /// The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
    ///
    /// **Note:** In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/get(repos/get)`.
    public func repos_get(_ input: Operations.repos_get.Input) async throws
        -> Operations.repos_get.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_get.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_get.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.repos_get.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.full_repository.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.not_found.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                case 301:
                    let headers: Components.Responses.moved_permanently.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.moved_permanently.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .movedPermanently(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List repository issues
    ///
    /// List issues in a repository. Only open issues will be listed.
    ///
    /// **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
    /// reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
    /// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
    /// request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/issues`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/issues/get(issues/list-for-repo)`.
    public func issues_list_for_repo(_ input: Operations.issues_list_for_repo.Input) async throws
        -> Operations.issues_list_for_repo.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.issues_list_for_repo.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/issues",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "milestone",
                    value: input.query.milestone
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "state",
                    value: input.query.state
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "assignee",
                    value: input.query.assignee
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "creator",
                    value: input.query.creator
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "mentioned",
                    value: input.query.mentioned
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "labels",
                    value: input.query.labels
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.issues_list_for_repo.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.issues_list_for_repo.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            [Components.Schemas.issue].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 301:
                    let headers: Components.Responses.moved_permanently.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.moved_permanently.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .movedPermanently(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.validation_failed.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.not_found.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create an issue comment
    ///
    ///
    /// You can use the REST API to create comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
    /// Creating content too quickly using this endpoint may result in secondary rate limiting.
    /// See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)"
    /// and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)"
    /// for details.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/issues/{issue_number}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/issues/{issue_number}/comments/post(issues/create-comment)`.
    public func issues_create_comment(_ input: Operations.issues_create_comment.Input) async throws
        -> Operations.issues_create_comment.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.issues_create_comment.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/issues/{}/comments",
                    parameters: [input.path.owner, input.path.repo, input.path.issue_number]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setRequiredRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers: Operations.issues_create_comment.Output.Created.Headers = .init(
                        Location: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Location",
                            as: Swift.String.self
                        )
                    )
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.issues_create_comment.Output.Created.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.issue_comment.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .created(.init(headers: headers, body: body))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 410:
                    let headers: Components.Responses.gone.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.gone.Body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .gone(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.validation_failed.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.not_found.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List pull requests
    ///
    /// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pulls`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pulls/get(pulls/list)`.
    public func pulls_list(_ input: Operations.pulls_list.Input) async throws
        -> Operations.pulls_list.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.pulls_list.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/pulls",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "state",
                    value: input.query.state
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "head",
                    value: input.query.head
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "base",
                    value: input.query.base
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.pulls_list.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.pulls_list.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            [Components.Schemas.pull_request_simple].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.validation_failed.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create a release
    ///
    /// Users with push access to the repository can create a release.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/releases`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/post(repos/create-release)`.
    public func repos_create_release(_ input: Operations.repos_create_release.Input) async throws
        -> Operations.repos_create_release.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_create_release.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/releases",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setRequiredRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers: Operations.repos_create_release.Output.Created.Headers = .init(
                        Location: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Location",
                            as: Swift.String.self
                        )
                    )
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.repos_create_release.Output.Created.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.release.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .created(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.repos_create_release.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.repos_create_release.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.validation_failed.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get the latest release
    ///
    /// View the latest published full release for the repository.
    ///
    /// The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/latest`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/latest/get(repos/get-latest-release)`.
    public func repos_get_latest_release(_ input: Operations.repos_get_latest_release.Input)
        async throws -> Operations.repos_get_latest_release.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_get_latest_release.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/releases/latest",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_get_latest_release.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.repos_get_latest_release.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.release.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
}
