// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import Foundation
#else
import Foundation
#endif
/// GitHub's v3 REST API.
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter { client.converter }
    /// Create an installation access token for an app
    ///
    /// Creates an installation access token that enables a GitHub App to make authenticated API requests for the app's installation on an organization or individual account. Installation tokens expire one hour from the time you create them. Using an expired token produces a status code of `401 - Unauthorized`, and requires creating a new installation token. By default the installation token has access to all repositories that the installation can access. To restrict the access to specific repositories, you can provide the `repository_ids` when creating the token. When you omit `repository_ids`, the response does not contain the `repositories` key.
    ///
    /// You must use a [JWT](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/#authenticating-as-a-github-app) to access this endpoint.
    ///
    /// - Remark: HTTP `POST /app/installations/{installation_id}/access_tokens`.
    /// - Remark: Generated from `#/paths//app/installations/{installation_id}/access_tokens/post(apps/create-installation-access-token)`.
    public func apps_create_installation_access_token(
        _ input: Operations.apps_create_installation_access_token.Input
    ) async throws -> Operations.apps_create_installation_access_token.Output {
        try await client.send(
            input: input,
            forOperation: Operations.apps_create_installation_access_token.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/app/installations/{}/access_tokens",
                    parameters: [input.path.installation_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers:
                        Operations.apps_create_installation_access_token.Output.Created.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.apps_create_installation_access_token.Output.Created.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.installation_token.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .created(.init(headers: headers, body: body))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 401:
                    let headers: Components.Responses.requires_authentication.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.requires_authentication.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.not_found.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.validation_failed.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get an organization
    ///
    /// To see many of the organization response values, you need to be an authenticated organization owner with the `admin:org` scope. When the value of `two_factor_requirement_enabled` is `true`, the organization requires all members, billing managers, and outside collaborators to enable [two-factor authentication](https://docs.github.com/articles/securing-your-account-with-two-factor-authentication-2fa/).
    ///
    /// GitHub Apps with the `Organization plan` permission can use this endpoint to retrieve information about an organization's GitHub plan. See "[Authenticating with GitHub Apps](https://docs.github.com/apps/building-github-apps/authenticating-with-github-apps/)" for details. For an example response, see 'Response with GitHub plan information' below."
    ///
    /// - Remark: HTTP `GET /orgs/{org}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/get(orgs/get)`.
    public func orgs_get(_ input: Operations.orgs_get.Input) async throws
        -> Operations.orgs_get.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.orgs_get.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/orgs/{}",
                    parameters: [input.path.org]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.orgs_get.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.orgs_get.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.organization_full.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.not_found.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get a repository
    ///
    /// The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
    ///
    /// **Note:** In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/get(repos/get)`.
    public func repos_get(_ input: Operations.repos_get.Input) async throws
        -> Operations.repos_get.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_get.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_get.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.repos_get.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.full_repository.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.not_found.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                case 301:
                    let headers: Components.Responses.moved_permanently.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.moved_permanently.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .movedPermanently(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List repository contributors
    ///
    /// Lists contributors to the specified repository and sorts them by the number of commits per contributor in descending order. This endpoint may return information that is a few hours old because the GitHub REST API caches contributor data to improve performance.
    ///
    /// GitHub identifies contributors by author email address. This endpoint groups contribution counts by GitHub user, which includes all associated email addresses. To improve performance, only the first 500 author email addresses in the repository link to GitHub users. The rest will appear as anonymous contributors without associated GitHub user information.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/contributors`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contributors/get(repos/list-contributors)`.
    public func repos_list_contributors(_ input: Operations.repos_list_contributors.Input)
        async throws -> Operations.repos_list_contributors.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_list_contributors.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/contributors",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "anon",
                    value: input.query.anon
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_list_contributors.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.repos_list_contributors.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            [Components.Schemas.contributor].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 204:
                    let headers: Operations.repos_list_contributors.Output.NoContent.Headers =
                        .init()
                    return .noContent(.init(headers: headers, body: nil))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.not_found.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List repository issues
    ///
    /// List issues in a repository. Only open issues will be listed.
    ///
    /// **Note**: GitHub's REST API considers every pull request an issue, but not every issue is a pull request. For this
    /// reason, "Issues" endpoints may return both issues and pull requests in the response. You can identify pull requests by
    /// the `pull_request` key. Be aware that the `id` of a pull request returned from "Issues" endpoints will be an _issue id_. To find out the pull
    /// request id, use the "[List pull requests](https://docs.github.com/rest/reference/pulls#list-pull-requests)" endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/issues`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/issues/get(issues/list-for-repo)`.
    public func issues_list_for_repo(_ input: Operations.issues_list_for_repo.Input) async throws
        -> Operations.issues_list_for_repo.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.issues_list_for_repo.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/issues",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "milestone",
                    value: input.query.milestone
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "state",
                    value: input.query.state
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "assignee",
                    value: input.query.assignee
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "creator",
                    value: input.query.creator
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "mentioned",
                    value: input.query.mentioned
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "labels",
                    value: input.query.labels
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.issues_list_for_repo.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.issues_list_for_repo.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            [Components.Schemas.issue].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 301:
                    let headers: Components.Responses.moved_permanently.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.moved_permanently.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .movedPermanently(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.validation_failed.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.not_found.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create an issue comment
    ///
    ///
    /// You can use the REST API to create comments on issues and pull requests. Every pull request is an issue, but not every issue is a pull request.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
    /// Creating content too quickly using this endpoint may result in secondary rate limiting.
    /// See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)"
    /// and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)"
    /// for details.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/issues/{issue_number}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/issues/{issue_number}/comments/post(issues/create-comment)`.
    public func issues_create_comment(_ input: Operations.issues_create_comment.Input) async throws
        -> Operations.issues_create_comment.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.issues_create_comment.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/issues/{}/comments",
                    parameters: [input.path.owner, input.path.repo, input.path.issue_number]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setRequiredRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers: Operations.issues_create_comment.Output.Created.Headers = .init(
                        Location: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Location",
                            as: Swift.String.self
                        )
                    )
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.issues_create_comment.Output.Created.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.issue_comment.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .created(.init(headers: headers, body: body))
                case 403:
                    let headers: Components.Responses.forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 410:
                    let headers: Components.Responses.gone.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.gone.Body = try converter.getResponseBodyAsJSON(
                        Components.Schemas.basic_error.self,
                        from: response.body,
                        transforming: { value in .json(value) }
                    )
                    return .gone(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.validation_failed.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.not_found.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List pull requests
    ///
    /// Draft pull requests are available in public repositories with GitHub Free and GitHub Free for organizations, GitHub Pro, and legacy per-repository billing plans, and in public and private repositories with GitHub Team and GitHub Enterprise Cloud. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pulls`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pulls/get(pulls/list)`.
    public func pulls_list(_ input: Operations.pulls_list.Input) async throws
        -> Operations.pulls_list.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.pulls_list.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/pulls",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "state",
                    value: input.query.state
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "head",
                    value: input.query.head
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "base",
                    value: input.query.base
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.pulls_list.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.pulls_list.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            [Components.Schemas.pull_request_simple].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 304:
                    let headers: Components.Responses.not_modified.Headers = .init()
                    return .notModified(.init(headers: headers, body: nil))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.validation_failed.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List review comments on a pull request
    ///
    /// Lists all review comments for a pull request. By default, review comments are in ascending order by ID.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pulls/{pull_number}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pulls/{pull_number}/comments/get(pulls/list-review-comments)`.
    public func pulls_list_review_comments(_ input: Operations.pulls_list_review_comments.Input)
        async throws -> Operations.pulls_list_review_comments.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.pulls_list_review_comments.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/pulls/{}/comments",
                    parameters: [input.path.owner, input.path.repo, input.path.pull_number]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "direction",
                    value: input.query.direction
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "since",
                    value: input.query.since
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.pulls_list_review_comments.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.pulls_list_review_comments.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            [Components.Schemas.pull_request_review_comment].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List releases
    ///
    /// This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/rest/reference/repos#list-repository-tags).
    ///
    /// Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/get(repos/list-releases)`.
    public func repos_list_releases(_ input: Operations.repos_list_releases.Input) async throws
        -> Operations.repos_list_releases.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_list_releases.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/releases",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_list_releases.Output.Ok.Headers = .init(
                        Link: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Link",
                            as: Components.Headers.link.self
                        )
                    )
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.repos_list_releases.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            [Components.Schemas.release].self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 404:
                    let headers: Components.Responses.not_found.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.not_found.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create a release
    ///
    /// Users with push access to the repository can create a release.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. See "[Secondary rate limits](https://docs.github.com/rest/overview/resources-in-the-rest-api#secondary-rate-limits)" and "[Dealing with secondary rate limits](https://docs.github.com/rest/guides/best-practices-for-integrators#dealing-with-secondary-rate-limits)" for details.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/releases`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/post(repos/create-release)`.
    public func repos_create_release(_ input: Operations.repos_create_release.Input) async throws
        -> Operations.repos_create_release.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_create_release.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/releases",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setRequiredRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 201:
                    let headers: Operations.repos_create_release.Output.Created.Headers = .init(
                        Location: try converter.getOptionalHeaderFieldAsText(
                            in: response.headerFields,
                            name: "Location",
                            as: Swift.String.self
                        )
                    )
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.repos_create_release.Output.Created.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.release.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .created(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.repos_create_release.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.repos_create_release.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.basic_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                case 422:
                    let headers: Components.Responses.validation_failed.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Components.Responses.validation_failed.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.validation_error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unprocessableEntity(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get the latest release
    ///
    /// View the latest published full release for the repository.
    ///
    /// The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/latest`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/latest/get(repos/get-latest-release)`.
    public func repos_get_latest_release(_ input: Operations.repos_get_latest_release.Input)
        async throws -> Operations.repos_get_latest_release.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.repos_get_latest_release.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/repos/{}/{}/releases/latest",
                    parameters: [input.path.owner, input.path.repo]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.repos_get_latest_release.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.repos_get_latest_release.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.release.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
}
